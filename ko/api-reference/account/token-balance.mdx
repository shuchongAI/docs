---
title: "토큰 잔액 조회"
description: "
- 현재 API 키의 남은 크레딧과 사용된 크레딧 조회

- 단일 토큰 사용량 모니터링

- CORS 크로스 오리진 요청 지원

- 실시간 잔액 모니터링
"
api: "GET https://api.apimart.ai/v1/balance"

---

현재 API 키(토큰)의 남은 잔액과 사용된 잔액을 조회합니다. 이 엔드포인트는 단일 토큰의 사용량을 모니터링하는 데 사용됩니다.

<RequestExample>

```bash cURL
curl --request GET \
  --url 'https://api.apimart.ai/v1/balance' \
  --header 'Authorization: Bearer <token>'
```

```python Python
import requests

API_BASE = 'https://api.apimart.ai'
API_KEY = 'sk-xxxxxxxxxxxxxxxxxxxxxx'

headers = {
    'Authorization': f'Bearer {API_KEY}'
}

def get_token_balance():
    response = requests.get(f'{API_BASE}/v1/balance', headers=headers)
    data = response.json()
    
    if data.get('success'):
        if data.get('unlimited_quota'):
            print("쿼터: 무제한")
        else:
            print(f"남은 잔액: {data['remain_balance']}")
        print(f"사용된 잔액: {data['used_balance']}")
    else:
        print(f"조회 실패: {data.get('message')}")
    
    return data

get_token_balance()
```

```javascript JavaScript
const API_BASE = 'https://api.apimart.ai';
const API_KEY = 'sk-xxxxxxxxxxxxxxxxxxxxxx';

async function getTokenBalance() {
  const response = await fetch(`${API_BASE}/v1/balance`, {
    headers: {
      'Authorization': `Bearer ${API_KEY}`
    }
  });
  
  const data = await response.json();
  
  if (data.success) {
    if (data.unlimited_quota) {
      console.log('쿼터: 무제한');
    } else {
      console.log(`남은 잔액: ${data.remain_balance}`);
    }
    console.log(`사용된 잔액: ${data.used_balance}`);
  } else {
    console.error('조회 실패:', data.message);
  }
  
  return data;
}

getTokenBalance();
```

```go Go
package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "net/http"
)

type BalanceResponse struct {
    Success        bool    `json:"success"`
    Message        string  `json:"message,omitempty"`
    RemainBalance  float64 `json:"remain_balance"`
    UsedBalance    float64 `json:"used_balance"`
    UnlimitedQuota bool    `json:"unlimited_quota"`
}

func main() {
    url := "https://api.apimart.ai/v1/balance"

    req, _ := http.NewRequest("GET", url, nil)
    req.Header.Set("Authorization", "Bearer <token>")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    body, _ := ioutil.ReadAll(resp.Body)
    
    var result BalanceResponse
    json.Unmarshal(body, &result)
    
    if result.Success {
        if result.UnlimitedQuota {
            fmt.Println("쿼터: 무제한")
        } else {
            fmt.Printf("남은 잔액: %.2f\n", result.RemainBalance)
        }
        fmt.Printf("사용된 잔액: %.2f\n", result.UsedBalance)
    }
}
```

```java Java
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URI;

public class Main {
    public static void main(String[] args) throws Exception {
        String url = "https://api.apimart.ai/v1/balance";

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Authorization", "Bearer <token>")
            .GET()
            .build();

        HttpResponse<String> response = client.send(request,
            HttpResponse.BodyHandlers.ofString());

        System.out.println(response.body());
    }
}
```

```php PHP
<?php

$api_key = 'sk-xxxxxxxxxxxxxxxxxxxxxx';

$ch = curl_init('https://api.apimart.ai/v1/balance');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, [
    "Authorization: Bearer $api_key"
]);

$response = curl_exec($ch);
curl_close($ch);

$data = json_decode($response, true);

if ($data['success']) {
    if ($data['unlimited_quota']) {
        echo "쿼터: 무제한\n";
    } else {
        echo "남은 잔액: " . $data['remain_balance'] . "\n";
    }
    echo "사용된 잔액: " . $data['used_balance'] . "\n";
} else {
    echo "조회 실패: " . $data['message'] . "\n";
}
?>
```

</RequestExample>

<ResponseExample>

```json 200 - 성공
{
  "success": true,
  "remain_balance": 10.5,
  "used_balance": 2.3,
  "unlimited_quota": false
}
```

```json 200 - 무제한 토큰
{
  "success": true,
  "remain_balance": -1,
  "used_balance": 2.3,
  "unlimited_quota": true
}
```

```json 200 - 토큰을 찾을 수 없음
{
  "success": false,
  "message": "토큰 정보를 가져오지 못했습니다: record not found"
}
```

```json 401
{
  "error": {
    "code": 401,
    "message": "인증에 실패했습니다. API 키를 확인하세요",
    "type": "authentication_error"
  }
}
```

```json 429
{
  "error": {
    "code": 429,
    "message": "요청이 너무 많습니다. 나중에 다시 시도하세요",
    "type": "rate_limit_error"
  }
}
```

</ResponseExample>

## 인증

<ParamField header="Authorization" type="string" required>
  모든 API 엔드포인트에는 Bearer Token 인증이 필요합니다

  API 키 받기:

  [API 키 관리 페이지](https://api.apimart.ai/console/token)에서 API 키를 받으세요

  요청 헤더에 추가:

  ```
  Authorization: Bearer YOUR_API_KEY
  ```
</ParamField>

## 엔드포인트

```
GET /v1/balance
GET /balance
```

두 엔드포인트는 동일한 기능을 가지고 있습니다. 둘 중 하나를 사용할 수 있습니다.

## 응답

<ResponseField name="success" type="boolean">
  요청 성공 여부
</ResponseField>

<ResponseField name="message" type="string">
  오류 메시지 (실패 시에만 반환)
</ResponseField>

<ResponseField name="remain_balance" type="float">
  토큰 남은 잔액 (성공 시 반환). `unlimited_quota`가 `true`일 때 값은 `-1`입니다
</ResponseField>

<ResponseField name="used_balance" type="float">
  토큰 사용된 잔액 (성공 시 반환)
</ResponseField>

<ResponseField name="unlimited_quota" type="boolean">
  토큰이 무제한인지 여부. `true`는 무제한, `false`는 제한됨을 의미합니다
</ResponseField>

## 사용 사례

- 단일 API 키의 소비 상황 모니터링
- 애플리케이션에서 현재 토큰 잔액 표시
- 잔액이 임계값 이하로 떨어지면 알림 설정

<Note>
**잔액 단위 정보**

잔액 값의 단위는 시스템 설정에 따라 다릅니다:
- **USD** - 미국 달러
- **CNY** - 중국 위안
- **Tokens** - 토큰 수
</Note>

<Tip>
**무제한 토큰**

토큰이 무제한으로 설정된 경우:
- `unlimited_quota` 필드는 `true`를 반환합니다
- `remain_balance` 필드는 `-1`을 반환합니다
- 해당 토큰은 제한 없이 무제한으로 사용할 수 있습니다
</Tip>

## 일반적인 오류

| 오류 메시지 | 원인 | 해결 방법 |
|-------------|------|-----------|
| Authorization 헤더 없음 | Authorization 헤더가 제공되지 않음 | `Authorization: Bearer sk-xxxxx` 헤더 추가 |
| 토큰 정보 가져오기 실패 | 토큰이 존재하지 않거나 삭제됨 | 토큰 키가 올바른지 확인 |

<Warning>
**보안 참고 사항**

API 키는 비밀번호와 같습니다. 안전하게 보관하고 다른 사람과 공유하지 마세요. 프로덕션에서는 항상 HTTPS를 사용하세요.
</Warning>

