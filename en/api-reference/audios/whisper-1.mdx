---
title: "Whisper-1 Audio Transcription"
description: "
- Supports speech recognition in 99 languages

- Multiple output formats: json, text, srt, vtt, etc.

- Maximum file size 25 MB
"
api: "POST https://api.apimart.ai/v1/audio/transcriptions"
contentType: "multipart/form-data"
---

<RequestExample>

```bash cURL
curl --request POST \
  --url https://api.apimart.ai/v1/audio/transcriptions \
  --header 'Authorization: Bearer <token>' \
  --header 'Content-Type: multipart/form-data' \
  --form 'file=@/path/to/audio.mp3' \
  --form 'model=whisper-1' \
  --form 'language=en' \
  --form 'response_format=json'
```

```python Python
import requests

url = "https://api.apimart.ai/v1/audio/transcriptions"

files = {
    "file": open("/path/to/audio.mp3", "rb")
}

data = {
    "model": "whisper-1",
    "language": "en",
    "response_format": "json"
}

headers = {
    "Authorization": "Bearer <token>"
}

response = requests.post(url, files=files, data=data, headers=headers)

print(response.json())
```

```javascript JavaScript
const url = "https://api.apimart.ai/v1/audio/transcriptions";

const formData = new FormData();
formData.append("file", audioFile);
formData.append("model", "whisper-1");
formData.append("language", "en");
formData.append("response_format", "json");

const headers = {
  "Authorization": "Bearer <token>"
};

fetch(url, {
  method: "POST",
  headers: headers,
  body: formData
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

```go Go
package main

import (
    "bytes"
    "fmt"
    "io"
    "mime/multipart"
    "net/http"
    "os"
)

func main() {
    url := "https://api.apimart.ai/v1/audio/transcriptions"

    file, _ := os.Open("/path/to/audio.mp3")
    defer file.Close()

    body := &bytes.Buffer{}
    writer := multipart.NewWriter(body)
    
    part, _ := writer.CreateFormFile("file", "audio.mp3")
    io.Copy(part, file)
    
    writer.WriteField("model", "whisper-1")
    writer.WriteField("language", "en")
    writer.WriteField("response_format", "json")
    writer.Close()

    req, _ := http.NewRequest("POST", url, body)
    req.Header.Set("Authorization", "Bearer <token>")
    req.Header.Set("Content-Type", writer.FormDataContentType())

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    responseBody, _ := io.ReadAll(resp.Body)
    fmt.Println(string(responseBody))
}
```

```java Java
import java.io.File;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URI;

public class Main {
    public static void main(String[] args) throws Exception {
        String url = "https://api.apimart.ai/v1/audio/transcriptions";
        
        File audioFile = new File("/path/to/audio.mp3");
        
        // Use Apache HttpClient or OkHttp library for multipart/form-data requests
    }
}
```

```php PHP
<?php

$url = "https://api.apimart.ai/v1/audio/transcriptions";

$file = new CURLFile('/path/to/audio.mp3', 'audio/mpeg', 'audio.mp3');

$data = [
    "file" => $file,
    "model" => "whisper-1",
    "language" => "en",
    "response_format" => "json"
];

$ch = curl_init($url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_POST, true);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
curl_setopt($ch, CURLOPT_HTTPHEADER, [
    "Authorization: Bearer <token>"
]);

$response = curl_exec($ch);
curl_close($ch);

echo $response;
?>
```

```ruby Ruby
require 'net/http'
require 'uri'

url = URI("https://api.apimart.ai/v1/audio/transcriptions")

File.open('/path/to/audio.mp3', 'rb') do |file|
  request = Net::HTTP::Post.new(url)
  request["Authorization"] = "Bearer <token>"
  
  form_data = [
    ['file', file, { filename: 'audio.mp3', content_type: 'audio/mpeg' }],
    ['model', 'whisper-1'],
    ['language', 'en'],
    ['response_format', 'json']
  ]
  
  request.set_form form_data, 'multipart/form-data'
  
  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  
  response = http.request(request)
  puts response.body
end
```

```swift Swift
import Foundation

let url = URL(string: "https://api.apimart.ai/v1/audio/transcriptions")!

var request = URLRequest(url: url)
request.httpMethod = "POST"
request.setValue("Bearer <token>", forHTTPHeaderField: "Authorization")

let boundary = "Boundary-\(UUID().uuidString)"
request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")

var body = Data()

// Add file
let fileURL = URL(fileURLWithPath: "/path/to/audio.mp3")
if let fileData = try? Data(contentsOf: fileURL) {
    body.append("--\(boundary)\r\n".data(using: .utf8)!)
    body.append("Content-Disposition: form-data; name=\"file\"; filename=\"audio.mp3\"\r\n".data(using: .utf8)!)
    body.append("Content-Type: audio/mpeg\r\n\r\n".data(using: .utf8)!)
    body.append(fileData)
    body.append("\r\n".data(using: .utf8)!)
}

// Add other fields
let fields = ["model": "whisper-1", "language": "en", "response_format": "json"]
for (key, value) in fields {
    body.append("--\(boundary)\r\n".data(using: .utf8)!)
    body.append("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n".data(using: .utf8)!)
    body.append("\(value)\r\n".data(using: .utf8)!)
}

body.append("--\(boundary)--\r\n".data(using: .utf8)!)

request.httpBody = body

let task = URLSession.shared.dataTask(with: request) { data, response, error in
    if let error = error {
        print("Error: \(error)")
        return
    }
    
    if let data = data, let responseString = String(data: data, encoding: .utf8) {
        print(responseString)
    }
}

task.resume()
```

```csharp C#
using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        var url = "https://api.apimart.ai/v1/audio/transcriptions";

        using var client = new HttpClient();
        client.DefaultRequestHeaders.Add("Authorization", "Bearer <token>");

        using var form = new MultipartFormDataContent();
        
        var fileStream = File.OpenRead("/path/to/audio.mp3");
        form.Add(new StreamContent(fileStream), "file", "audio.mp3");
        form.Add(new StringContent("whisper-1"), "model");
        form.Add(new StringContent("en"), "language");
        form.Add(new StringContent("json"), "response_format");

        var response = await client.PostAsync(url, form);
        var result = await response.Content.ReadAsStringAsync();

        Console.WriteLine(result);
    }
}
```

```c C
#include <stdio.h>
#include <curl/curl.h>

int main(void) {
    CURL *curl;
    CURLcode res;
    struct curl_httppost *formpost = NULL;
    struct curl_httppost *lastptr = NULL;
    struct curl_slist *headers = NULL;

    curl_global_init(CURL_GLOBAL_ALL);

    curl_formadd(&formpost, &lastptr,
                 CURLFORM_COPYNAME, "file",
                 CURLFORM_FILE, "/path/to/audio.mp3",
                 CURLFORM_END);

    curl_formadd(&formpost, &lastptr,
                 CURLFORM_COPYNAME, "model",
                 CURLFORM_COPYCONTENTS, "whisper-1",
                 CURLFORM_END);

    curl_formadd(&formpost, &lastptr,
                 CURLFORM_COPYNAME, "language",
                 CURLFORM_COPYCONTENTS, "en",
                 CURLFORM_END);

    curl_formadd(&formpost, &lastptr,
                 CURLFORM_COPYNAME, "response_format",
                 CURLFORM_COPYCONTENTS, "json",
                 CURLFORM_END);

    curl = curl_easy_init();
    headers = curl_slist_append(headers, "Authorization: Bearer <token>");

    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, "https://api.apimart.ai/v1/audio/transcriptions");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);

        res = curl_easy_perform(curl);

        if(res != CURLE_OK) {
            fprintf(stderr, "curl_easy_perform() failed: %s\n",
                    curl_easy_strerror(res));
        }

        curl_easy_cleanup(curl);
        curl_formfree(formpost);
        curl_slist_free_all(headers);
    }

    curl_global_cleanup();
    return 0;
}
```

```objectivec Objective-C
#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSURL *url = [NSURL URLWithString:@"https://api.apimart.ai/v1/audio/transcriptions"];
        
        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
        [request setHTTPMethod:@"POST"];
        [request setValue:@"Bearer <token>" forHTTPHeaderField:@"Authorization"];
        
        NSString *boundary = @"Boundary-12345";
        NSString *contentType = [NSString stringWithFormat:@"multipart/form-data; boundary=%@", boundary];
        [request setValue:contentType forHTTPHeaderField:@"Content-Type"];
        
        NSMutableData *body = [NSMutableData data];
        
        // Add file
        NSData *fileData = [NSData dataWithContentsOfFile:@"/path/to/audio.mp3"];
        [body appendData:[[NSString stringWithFormat:@"--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
        [body appendData:[@"Content-Disposition: form-data; name=\"file\"; filename=\"audio.mp3\"\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
        [body appendData:[@"Content-Type: audio/mpeg\r\n\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
        [body appendData:fileData];
        [body appendData:[@"\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
        
        // Add other fields
        NSDictionary *fields = @{@"model": @"whisper-1", @"language": @"en", @"response_format": @"json"};
        for (NSString *key in fields) {
            [body appendData:[[NSString stringWithFormat:@"--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
            [body appendData:[[NSString stringWithFormat:@"Content-Disposition: form-data; name=\"%@\"\r\n\r\n", key] dataUsingEncoding:NSUTF8StringEncoding]];
            [body appendData:[[NSString stringWithFormat:@"%@\r\n", fields[key]] dataUsingEncoding:NSUTF8StringEncoding]];
        }
        
        [body appendData:[[NSString stringWithFormat:@"--%@--\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
        [request setHTTPBody:body];
        
        NSURLSessionDataTask *task = [[NSURLSession sharedSession] 
            dataTaskWithRequest:request
            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
                if (error) {
                    NSLog(@"Error: %@", error);
                    return;
                }
                NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
                NSLog(@"%@", result);
            }];
        
        [task resume];
        [[NSRunLoop mainRunLoop] run];
    }
    return 0;
}
```

```ocaml OCaml
(* Requires cohttp and yojson libraries *)
open Lwt
open Cohttp
open Cohttp_lwt_unix

let url = "https://api.apimart.ai/v1/audio/transcriptions"

(* Note: Multipart form data handling in OCaml requires additional libraries *)
let () =
  print_endline "Use multipart_form library to handle file uploads"
```

```dart Dart
import 'dart:io';
import 'package:http/http.dart' as http;

void main() async {
  final url = Uri.parse('https://api.apimart.ai/v1/audio/transcriptions');
  
  var request = http.MultipartRequest('POST', url);
  request.headers['Authorization'] = 'Bearer <token>';
  
  request.files.add(await http.MultipartFile.fromPath('file', '/path/to/audio.mp3'));
  request.fields['model'] = 'whisper-1';
  request.fields['language'] = 'en';
  request.fields['response_format'] = 'json';
  
  var response = await request.send();
  var responseData = await response.stream.bytesToString();
  
  print(responseData);
}
```

```r R
library(httr)

url <- "https://api.apimart.ai/v1/audio/transcriptions"

response <- POST(
  url,
  add_headers(Authorization = "Bearer <token>"),
  body = list(
    file = upload_file("/path/to/audio.mp3"),
    model = "whisper-1",
    language = "en",
    response_format = "json"
  ),
  encode = "multipart"
)

cat(content(response, "text"))
```

</RequestExample>

<ResponseExample>

```json 200
{
  "text": "This is a transcribed text from the test audio."
}
```

```json 200 (Verbose Format)
{
  "task": "transcribe",
  "language": "en",
  "duration": 8.5,
  "text": "This is a transcribed text from the test audio.",
  "segments": [
    {
      "id": 0,
      "seek": 0,
      "start": 0.0,
      "end": 3.5,
      "text": "This is a transcribed text",
      "tokens": [50364, 1234, 5678],
      "temperature": 0.0,
      "avg_logprob": -0.3,
      "compression_ratio": 1.2,
      "no_speech_prob": 0.01
    }
  ]
}
```

```srt 200 (SRT Subtitle Format)
1
00:00:00,000 --> 00:00:03,500
This is a transcribed text

2
00:00:03,500 --> 00:00:08,500
from the test audio.
```

```json 400
{
  "error": {
    "code": 400,
    "message": "Invalid request parameters",
    "type": "invalid_request_error"
  }
}
```

```json 401
{
  "error": {
    "code": 401,
    "message": "Authentication failed, please check your API key",
    "type": "authentication_error"
  }
}
```

```json 402
{
  "error": {
    "code": 402,
    "message": "Insufficient account balance, please recharge",
    "type": "payment_required"
  }
}
```

```json 413
{
  "error": {
    "code": 413,
    "message": "File size exceeds limit (maximum 25MB)",
    "type": "invalid_request_error"
  }
}
```

```json 429
{
  "error": {
    "code": 429,
    "message": "Too many requests, please try again later",
    "type": "rate_limit_error"
  }
}
```

```json 500
{
  "error": {
    "code": 500,
    "message": "Internal server error, please try again later",
    "type": "server_error"
  }
}
```

```json 502
{
  "error": {
    "code": 502,
    "message": "Bad gateway, server temporarily unavailable",
    "type": "bad_gateway"
  }
}
```

</ResponseExample>

## Authorizations

<ParamField header="Authorization" type="string" required>
  All interfaces require Bearer Token authentication

  Get API Key:

  Visit [API Key Management Page](https://apimart.ai/console/token) to get your API Key

  Add to request header:

  ```
  Authorization: Bearer YOUR_API_KEY
  ```
</ParamField>

## Body

<Note>
  **⚠️ Online testing (Try it) is not supported for this endpoint**
  
  Due to file upload limitations, please test using:
  - **Apifox / Postman** - Manually change `file` parameter to file type after importing
  - **cURL** - Refer to code examples on the right
  - **SDK** - Use SDK examples in various languages
</Note>

<ParamField body="file" type="string" format="binary" required>
  Audio file to transcribe (File type)

  **⚠️ Note**: When testing with Apifox or similar tools:
  1. After importing, manually change this parameter type to `file`
  2. Ensure request Content-Type is `multipart/form-data`

  Supported formats: mp3, mp4, mpeg, mpga, m4a, wav, webm
  
  Maximum file size: 25 MB
</ParamField>

<ParamField body="model" type="string" default="whisper-1" required>
  Speech recognition model name

  Example: `"whisper-1"`
</ParamField>

<ParamField body="language" type="string">
  Language code of the audio (ISO-639-1 format)

  Specifying the language can improve accuracy and speed
  
  Supported languages include: zh (Chinese), en (English), ja (Japanese), ko (Korean), and 99 other languages
  
  Example: `"en"`
</ParamField>

<ParamField body="prompt" type="string">
  Optional text prompt to guide the transcription style or continue from previous audio

  Maximum 224 tokens
</ParamField>

<ParamField body="response_format" type="string" default="json">
  Output format

  Supported formats:
  - `json` - JSON format (text only)
  - `text` - Plain text
  - `srt` - SRT subtitle format
  - `verbose_json` - Verbose JSON format (includes timestamps and metadata)
  - `vtt` - WebVTT subtitle format
</ParamField>

<ParamField body="temperature" type="number" default="0">
  Sampling temperature, range 0 to 1

  Higher values (like 0.8) make output more random, lower values (like 0.2) make it more deterministic and consistent
</ParamField>

## Response

<ResponseField name="text" type="string">
  Transcribed text content
</ResponseField>

<ResponseField name="task" type="string">
  Task type, fixed as `transcribe`
  
  Only returned in verbose_json format
</ResponseField>

<ResponseField name="language" type="string">
  Detected or specified language code
  
  Only returned in verbose_json format
</ResponseField>

<ResponseField name="duration" type="number">
  Audio duration (seconds)
  
  Only returned in verbose_json format
</ResponseField>

<ResponseField name="segments" type="array">
  Array of text segments
  
  Only returned in verbose_json format

  <Expandable title="Properties">
    <ResponseField name="id" type="integer">
      Segment ID
    </ResponseField>

    <ResponseField name="start" type="number">
      Segment start time (seconds)
    </ResponseField>

    <ResponseField name="end" type="number">
      Segment end time (seconds)
    </ResponseField>

    <ResponseField name="text" type="string">
      Segment text content
    </ResponseField>

    <ResponseField name="temperature" type="number">
      Sampling temperature used
    </ResponseField>

    <ResponseField name="avg_logprob" type="number">
      Average log probability
    </ResponseField>

    <ResponseField name="compression_ratio" type="number">
      Compression ratio
    </ResponseField>

    <ResponseField name="no_speech_prob" type="number">
      No speech probability
    </ResponseField>
  </Expandable>
</ResponseField>

